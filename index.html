<!DOCTYPE html>
<html lang="en" data-theme="light">
  <head>
    <meta charset="UTF-8" />
    <title>BeforeTheBet ‚Äì Demo MVP</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <style>
      /* =========================================================
         THEME TOKENS
         - Light is default (data-theme="light")
         - Toggle sets html[data-theme="dark"]
         ========================================================= */

      :root {
        --bg: #f6f7fb;
        --card: #ffffff;
        --border: #e5e7eb;
        --text: #111827;
        --muted: #6b7280;

        --blue: #2563eb;   /* 50/50 baseline (MyBias before reveal) */
        --green: #16a34a;  /* community revealed */
        --red: #dc2626;

        --shadow: 0 18px 40px rgba(0, 0, 0, 0.12);
        --shadow-strong: 0 22px 50px rgba(0, 0, 0, 0.16);
      }

      html[data-theme="dark"] {
        color-scheme: dark;
        --bg: #020617;
        --card: #020617;
        --border: #1e293b;
        --text: #e2e8f0;
        --muted: #94a3b8;

        --blue: #3b82f6;
        --green: #22c55e;
        --red: #ef4444;

        --shadow: 0 18px 40px rgba(0, 0, 0, 0.55);
        --shadow-strong: 0 22px 50px rgba(0, 0, 0, 0.65);
      }

      * { box-sizing: border-box; }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", sans-serif;
        background: var(--bg);
        color: var(--text);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      .app-shell {
        min-height: 100vh;
        display: none; /* hidden until auth success */
        flex-direction: column;
      }

      header, footer {
        height: 56px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 16px;
        border-bottom: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.75);
        backdrop-filter: blur(10px);
        z-index: 10;
      }

      html[data-theme="dark"] header,
      html[data-theme="dark"] footer {
        background: rgba(2, 6, 23, 0.65);
      }

      footer {
        border-top: 1px solid var(--border);
        border-bottom: none;
        justify-content: center;
        font-size: 11px;
        color: var(--muted);
      }

      .header-left { display: flex; align-items: center; gap: 8px; }

      .logo-group { position: relative; display: flex; align-items: center; }
      .logo-button {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 12px;
        border-radius: 999px;
        border: 1px solid transparent;
        background: transparent;
        cursor: pointer;
        color: var(--text);
      }
      .logo-button:hover { border-color: var(--border); }

      .logo {
        font-size: 12px;
        font-weight: 700;
        letter-spacing: 0.18em;
        text-transform: uppercase;
        color: var(--muted);
      }
      .logo-caret { font-size: 10px; color: var(--muted); }

      .sports-menu {
        position: absolute;
        top: 115%;
        left: 0;
        background: var(--card);
        border-radius: 16px;
        border: 1px solid var(--border);
        box-shadow: var(--shadow);
        padding: 8px 0;
        min-width: 260px;
        display: none;
        z-index: 60;
        max-height: 70vh;
        overflow: auto;
      }
      .sports-menu.open { display: block; }

      .sports-menu-item {
        padding: 8px 12px 6px;
        font-size: 12px;
        cursor: default;
      }
      .sports-menu-item:hover { background: rgba(0,0,0,0.03); }
      html[data-theme="dark"] .sports-menu-item:hover { background: rgba(255,255,255,0.05); }

      .sports-menu-item-title { font-weight: 700; color: var(--text); }
      .sports-games-submenu {
        margin-top: 6px;
        margin-left: 6px;
        padding-left: 10px;
        border-left: 1px solid var(--border);
      }
      .game-item {
        font-size: 11px;
        color: var(--muted);
        padding: 4px 0;
        cursor: pointer;
      }
      .game-item:hover { color: var(--text); }

      #back-to-sports {
        display: none;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: transparent;
        color: var(--muted);
        font-size: 11px;
        padding: 6px 10px;
        cursor: pointer;
      }
      #back-to-sports:hover { color: var(--text); }

      .user-menu-wrapper { position: relative; }
      .menu-placeholder {
        font-size: 11px;
        color: var(--muted);
        cursor: pointer;
        padding: 6px 12px;
        border-radius: 999px;
        border: 1px solid transparent;
        background: transparent;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }
      .menu-placeholder:hover { border-color: var(--border); color: var(--text); }

      .user-dropdown {
        position: absolute;
        right: 0;
        top: 115%;
        background: var(--card);
        border-radius: 16px;
        border: 1px solid var(--border);
        box-shadow: var(--shadow);
        min-width: 220px;
        padding: 6px 0;
        display: none;
        z-index: 60;
      }
      .user-dropdown.open { display: block; }
      .user-dropdown-item {
        padding: 8px 12px;
        font-size: 12px;
        cursor: pointer;
        color: var(--text);
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
      }
      .user-dropdown-item:hover { background: rgba(0,0,0,0.03); }
      html[data-theme="dark"] .user-dropdown-item:hover { background: rgba(255,255,255,0.05); }
      .user-dropdown-separator { border-top: 1px solid var(--border); margin: 6px 0; }

      main {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: stretch;
        justify-content: center;
        padding: 24px 16px;
      }

      .content {
        max-width: 960px;
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        gap: 24px;
        align-items: stretch;
      }

      .title-block { text-align: center; }
      .title-block h1 { font-size: 28px; margin: 0 0 8px; }
      .title-block p { margin: 0; font-size: 14px; color: var(--muted); }
      .title-block .directions { margin-top: 6px; font-size: 12px; color: var(--muted); }

      @media (min-width: 768px) {
        .title-block h1 { font-size: 32px; }
        .title-block .directions { font-size: 13px; }
      }

      /* Card stack */
      .card-container { display: flex; align-items: center; justify-content: center; }
      .card-click-area {
        position: relative;
        width: 100%;
        max-width: 380px;
        aspect-ratio: 2.5 / 3.5;
        perspective: 1200px;
        cursor: pointer;
      }
      @media (min-width: 1024px) { .card-click-area { max-width: 420px; } }

      .card, .stack-card {
        position: absolute;
        inset: 0;
        border-radius: 24px;
        border: 1px solid var(--border);
        background: var(--card);
        box-shadow: var(--shadow-strong);
        overflow: hidden;
      }

      .card-main { transform-style: preserve-3d; transition: transform 0.5s ease; z-index: 3; }
      .stack-card { pointer-events: none; opacity: 0.35; z-index: 0; }
      .stack-card.stack-1 { transform: translateY(10px) translateX(6px) scale(0.97); }
      .stack-card.stack-2 { transform: translateY(18px) translateX(10px) scale(0.94); opacity: 0.25; }
      .stack-card.stack-3 { transform: translateY(26px) translateX(14px) scale(0.90); opacity: 0.15; }

      .card-face {
        position: absolute;
        inset: 0;
        padding: 18px 16px 14px;
        display: flex;
        flex-direction: column;
        backface-visibility: hidden;
      }

      .card-front { align-items: center; text-align: center; justify-content: center; gap: 12px; transform: rotateY(0deg); transition: transform 0.5s ease; }
      .card-back { transform: rotateY(180deg); justify-content: flex-start; transition: transform 0.5s ease; }

      .card-main.flipped .card-front { transform: rotateY(-180deg); }
      .card-main.flipped .card-back { transform: rotateY(0deg); }

      /* Sport icon circle */
      .sport-logo-circle {
        width: 120px; height: 120px; border-radius: 999px;
        display: flex; align-items: center; justify-content: center;
        font-size: 42px; box-shadow: var(--shadow);
        background: radial-gradient(circle at top left, #eef2ff, #dbeafe);
      }
      html[data-theme="dark"] .sport-logo-circle {
        background: radial-gradient(circle at top left, rgba(59,130,246,0.25), rgba(2,6,23,0.15));
      }
      .sport-front-name { font-size: 18px; font-weight: 700; margin-top: 10px; }
      .sport-front-code { font-size: 12px; text-transform: uppercase; letter-spacing: 0.16em; color: var(--muted); margin-top: 4px; }

      .tap-hint { position: absolute; bottom: 10px; right: 14px; font-size: 10px; color: var(--muted); pointer-events: none; }
      .index-indicator { position: absolute; bottom: 10px; left: 14px; font-size: 10px; color: var(--muted); }

      /* Back content */
      .back-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 8px; margin-bottom: 8px; }
      .back-title { font-size: 16px; font-weight: 800; }
      .back-sub { font-size: 11px; color: var(--muted); text-align: right; }

      .matchups-list {
        margin-top: 6px;
        flex: 1;
        overflow-y: auto;
        padding-right: 4px;
      }

      .matchup-card {
        border-radius: 18px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.9);
        padding: 10px 10px 8px;
        margin-bottom: 8px;
        position: relative;
        transition: transform 0.2s ease, opacity 0.2s ease;
      }
      html[data-theme="dark"] .matchup-card { background: rgba(2, 6, 23, 0.85); }

      .matchup-card.disabled {
        opacity: 0.45;
        filter: grayscale(0.4);
      }

      .matchup-top { display: flex; justify-content: space-between; align-items: flex-start; gap: 6px; margin-bottom: 6px; }
      .matchup-label { font-size: 13px; font-weight: 700; color: var(--text); }
      .matchup-line { font-size: 11px; color: var(--muted); }
      .matchup-tag { font-size: 11px; color: var(--muted); text-align: right; }

      /* SideBias (MyBias) bar */
      .bias-container { margin-top: 6px; }
      .bias-bar-bg {
        height: 10px;
        border-radius: 999px;
        background: rgba(148,163,184,0.25);
        overflow: hidden;
        border: 1px solid var(--border);
      }
      .bias-bar-fill {
        height: 100%;
        border-radius: 999px;
        transition: width 0.25s ease, background 0.25s ease;
        background: linear-gradient(90deg, var(--blue), rgba(37,99,235,0.65));
      }
      .bias-labels {
        display: flex;
        justify-content: space-between;
        font-size: 11px;
        margin-top: 4px;
        gap: 10px;
      }
      .bias-left { color: var(--muted); font-weight: 700; }
      .bias-right { color: var(--muted); font-weight: 700; text-align: right; }

      .back-footer-note {
        margin-top: 8px;
        font-size: 11px;
        color: var(--muted);
      }

      .category-header {
        margin: 10px 2px 6px;
        font-size: 11px;
        color: var(--muted);
        text-transform: uppercase;
        letter-spacing: 0.16em;
        font-weight: 800;
      }

      /* Toast */
      .swipe-toast {
        position: fixed;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%) translateY(20px);
        background: rgba(255,255,255,0.92);
        border-radius: 999px;
        border: 1px solid var(--border);
        padding: 8px 14px;
        font-size: 12px;
        color: var(--text);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 120;
        white-space: nowrap;
        box-shadow: var(--shadow);
      }
      html[data-theme="dark"] .swipe-toast { background: rgba(2,6,23,0.92); }

      .swipe-toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }

      /* In-app modal (NOT system confirm/alert) */
      .modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.35);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 200;
        padding: 18px;
      }
      html[data-theme="dark"] .modal-overlay { background: rgba(0,0,0,0.55); }

      .modal-overlay.open { display: flex; }

      .modal-card {
        width: 100%;
        max-width: 420px;
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 20px;
        box-shadow: var(--shadow-strong);
        padding: 16px 14px 12px;
      }
      .modal-title { font-size: 14px; font-weight: 900; margin: 0 0 6px; }
      .modal-body { font-size: 12px; color: var(--muted); margin: 0 0 12px; line-height: 1.4; }
      .modal-actions { display: flex; gap: 10px; }
      .modal-btn {
        flex: 1;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: transparent;
        padding: 10px 12px;
        cursor: pointer;
        font-size: 12px;
        font-weight: 800;
        color: var(--text);
      }
      .modal-btn.primary {
        border: none;
        background: var(--green);
        color: white;
      }
      .modal-btn.danger {
        border: none;
        background: var(--red);
        color: white;
      }

      /* Auth overlay */
      #auth-overlay {
        position: fixed;
        inset: 0;
        background: rgba(255,255,255,0.95);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 300;
        padding: 18px;
      }
      html[data-theme="dark"] #auth-overlay { background: rgba(2,6,23,0.92); }

      .auth-card {
        width: 100%;
        max-width: 380px;
        background: var(--card);
        border-radius: 24px;
        border: 1px solid var(--border);
        padding: 20px 18px 16px;
        box-shadow: var(--shadow-strong);
      }
      .auth-title { font-size: 18px; font-weight: 900; margin-bottom: 4px; }
      .auth-subtitle { font-size: 13px; color: var(--muted); margin-bottom: 12px; }

      .auth-field { margin-bottom: 10px; }
      .auth-field label { display:block; font-size: 11px; color: var(--muted); margin-bottom: 4px; font-weight: 800; }
      .auth-field input {
        width: 100%;
        padding: 9px 10px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: transparent;
        color: var(--text);
        font-size: 12px;
        outline: none;
      }

      .auth-actions { display: flex; gap: 10px; margin-top: 8px; }
      .auth-primary, .auth-secondary {
        flex: 1;
        padding: 10px 12px;
        border-radius: 999px;
        border: none;
        font-size: 12px;
        cursor: pointer;
        font-weight: 900;
      }
      .auth-primary { background: var(--green); color: white; }
      .auth-secondary { background: transparent; border: 1px solid var(--border); color: var(--text); }

      .auth-note { margin-top: 10px; font-size: 10px; color: var(--muted); line-height: 1.4; }

      @media (max-width: 480px) {
        .card-click-area { max-width: 340px; }
        .sport-logo-circle { width: 104px; height: 104px; font-size: 36px; }
        .swipe-toast { font-size: 11px; max-width: 90%; white-space: normal; text-align: center; }
      }
    </style>
  </head>

  <body>
    <!-- AUTH OVERLAY (REQUIRED) -->
    <div id="auth-overlay">
      <div class="auth-card">
        <div class="auth-title">BeforeTheBet</div>
        <div class="auth-subtitle">Sign in to start swiping.</div>

        <div class="auth-field">
          <label for="email">Email</label>
          <input id="email" type="email" placeholder="you@email.com" autocomplete="email" />
        </div>

        <div class="auth-field">
          <label for="password">Password</label>
          <input id="password" type="password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" autocomplete="current-password" />
        </div>

        <div class="auth-actions">
          <button class="auth-secondary" id="signUpBtn" type="button">Create Account</button>
          <button class="auth-primary" id="signInBtn" type="button">Sign In</button>
        </div>

        <div class="auth-note" id="auth-note">
          Note: If your Supabase project requires email confirmation, you must confirm the link before signing in.
        </div>
      </div>
    </div>

    <!-- In-app modal -->
    <div class="modal-overlay" id="modal-overlay">
      <div class="modal-card">
        <div class="modal-title" id="modal-title">Confirm</div>
        <p class="modal-body" id="modal-body">Are you sure?</p>
        <div class="modal-actions" id="modal-actions"></div>
      </div>
    </div>

    <div class="app-shell">
      <header>
        <div class="header-left">
          <div class="logo-group" id="logo-group">
            <button id="app-logo-button" class="logo-button" type="button">
              <span class="logo">BEFORETHEBET</span>
              <span class="logo-caret">‚ñæ</span>
            </button>
            <div id="sports-menu" class="sports-menu"></div>
          </div>
          <button id="back-to-sports" type="button">‚Üê Back</button>
        </div>

        <div class="user-menu-wrapper" id="user-menu-wrapper">
          <button class="menu-placeholder" id="user-menu-button" type="button">
            <span id="user-menu-label">My Hub</span>
            <span>‚ñæ</span>
          </button>
          <div class="user-dropdown" id="user-dropdown"></div>
        </div>
      </header>

      <main>
        <div class="content">
          <div class="title-block">
            <h1 id="main-title">Select Your Sport</h1>
            <p id="subtitle">One card at a time. Most popular lines by sport.</p>
            <div class="directions" id="directions">
              Double-click the <strong>center</strong> to flip.
              In sport view, tap <strong>right edge</strong> for next sport and <strong>left edge</strong> for previous.
            </div>
          </div>

          <div class="card-container">
            <div class="card-click-area" id="card-click-area">
              <div class="stack-card stack-3"></div>
              <div class="stack-card stack-2"></div>
              <div class="stack-card stack-1"></div>

              <div class="card card-main" id="sport-card">
                <!-- FRONT -->
                <div class="card-face card-front" id="card-front">
                  <div class="sport-logo-circle" id="sport-logo">üèà</div>
                  <div class="sport-front-name" id="sport-name"></div>
                  <div class="sport-front-code" id="sport-code"></div>
                  <div class="tap-hint" id="tap-hint-front">Double-click center to flip ‚Üª</div>
                  <div class="index-indicator" id="index-indicator"></div>
                </div>

                <!-- BACK -->
                <div class="card-face card-back" id="card-back">
                  <div class="back-header">
                    <div class="back-title" id="back-title"></div>
                    <div class="back-sub" id="back-sub"></div>
                  </div>

                  <div class="matchups-list" id="matchups-list"></div>

                  <div class="back-footer-note" id="back-footer-note">
                    SideBias is demo data until you connect real community signals.
                  </div>

                  <div class="tap-hint" id="tap-hint-back">Double-click center to flip ‚Ü∫</div>
                  <div class="index-indicator" id="index-indicator-back"></div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </main>

      <footer>BeforeTheBet ‚Ä¢ Demo MVP</footer>
    </div>

    <div class="swipe-toast" id="swipe-toast"></div>

    <!-- Supabase (non-module; reliable) -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <script>
      /************************************************************
       * CONFIG
       ************************************************************/
      const SUPABASE_URL = "https://kmgrpyvcxonfjswxusbt.supabase.co";
      const SUPABASE_ANON_KEY =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImttZ3JweXZjeG9uZmpzd3h1c2J0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU2NjE4NTIsImV4cCI6MjA4MTIzNzg1Mn0.teDypPoT-TMPkIDGemYVRfCNdmK0uAbOCDaiHfNmgac";

      // Optional: Your SportsDataIO key (NFL live odds/props). Leave blank to use sample.
      const NFL_API_KEY = "05e71f5146e8488d9ff3c537b89f4ffc";

      // After a user swipes 5 times total, reveal community biases in green.
      const REVEAL_COMMUNITY_AFTER = 5;

      // Supabase table for cross-device persistence (fallback to localStorage if missing)
      const PERSIST_TABLE = "btb_items";

      /************************************************************
       * STATE
       ************************************************************/
      const CATEGORY_LABELS = {
        spread: "Spreads",
        total: "Over / Unders",
        points: "Points",
        props: "Props",
        alt: "Alternate Lines",
        moneyline: "Moneyline",
        other: "Other"
      };
      const CATEGORY_ORDER = ["spread", "moneyline", "total", "points", "props", "alt", "other"];

      // Books
      const BOOKS = ["FanDuel", "DraftKings", "BetMGM", "Caesars", "ESPN BET", "PointsBet"];

      // Sports (MLB removed)
      const SPORTS = [
        {
          id: "nfl",
          name: "NFL",
          code: "National Football League",
          emoji: "üèà",
          matchups: [
            {
              name: "Chiefs @ Bills",
              lines: [
                { label: "Mahomes o1.5 Passing TDs", communityConfident: 68, communityDoubt: 32, category: "props", book: "FanDuel" },
                { label: "Allen o36.5 Rush Yards", communityConfident: 57, communityDoubt: 43, category: "props", book: "BetMGM" },
                { label: "Total Points o51.5", communityConfident: 54, communityDoubt: 46, category: "total", book: "ESPN BET" },
                { label: "Chiefs -2.5", communityConfident: 52, communityDoubt: 48, category: "spread", book: "PointsBet" }
              ]
            },
            {
              name: "Eagles @ Cowboys",
              lines: [
                { label: "Hurts o44.5 Rush Yards", communityConfident: 55, communityDoubt: 45, category: "props", book: "FanDuel" },
                { label: "Eagles +3.5", communityConfident: 58, communityDoubt: 42, category: "spread", book: "BetMGM" },
                { label: "Total o48.5", communityConfident: 51, communityDoubt: 49, category: "total", book: "Caesars" }
              ]
            }
          ]
        },
        {
          id: "nba",
          name: "NBA",
          code: "National Basketball Association",
          emoji: "üèÄ",
          matchups: [
            {
              name: "Lakers @ Warriors",
              lines: [
                { label: "LeBron o26.5 Points", communityConfident: 61, communityDoubt: 39, category: "points", book: "FanDuel" },
                { label: "Curry o4.5 3PM", communityConfident: 64, communityDoubt: 36, category: "points", book: "DraftKings" },
                { label: "Total o236.5", communityConfident: 52, communityDoubt: 48, category: "total", book: "Caesars" }
              ]
            },
            {
              name: "Celtics @ Knicks",
              lines: [
                { label: "Brunson o24.5 Pts", communityConfident: 56, communityDoubt: 44, category: "points", book: "DraftKings" },
                { label: "Celtics -4.5", communityConfident: 58, communityDoubt: 42, category: "spread", book: "ESPN BET" }
              ]
            }
          ]
        }
      ];

      // Modes
      // sports | matchups | allLines | lineDetails | mybias | locks | archives
      let mode = "sports";
      let currentSportIndex = 0;
      let currentMatchupIndex = 0;
      let flipped = false;

      // Line details
      let previousModeBeforeLineDetails = null;
      let currentLineDetailMeta = null;

      // Auth + user
      let currentUser = null; // supabase user object
      let isAuthed = false;

      // My swipes store (in-memory)
      // key -> { key, user_id, sportId, sportIndex, matchupIndex, matchupName, label, book, category,
      //          vote: "confident"|"doubt", status: "mybias"|"lock"|"archived", createdAt, updatedAt,
      //          revealedBias: boolean }
      const store = {};

      // Total swipes by user (for reveal behavior)
      let userSwipeCount = 0;

      // Persist fallback
      const LS_KEY = "btb_items_v1";
      const LS_THEME = "btb_theme_v1";

      /************************************************************
       * DOM
       ************************************************************/
      const appShell = document.querySelector(".app-shell");

      const cardEl = document.getElementById("sport-card");
      const cardClickArea = document.getElementById("card-click-area");

      const logoEl = document.getElementById("sport-logo");
      const nameEl = document.getElementById("sport-name");
      const codeEl = document.getElementById("sport-code");
      const tapHintFrontEl = document.getElementById("tap-hint-front");
      const tapHintBackEl = document.getElementById("tap-hint-back");

      const indexIndicatorFront = document.getElementById("index-indicator");
      const indexIndicatorBack = document.getElementById("index-indicator-back");

      const backTitleEl = document.getElementById("back-title");
      const backSubEl = document.getElementById("back-sub");
      const matchupsListEl = document.getElementById("matchups-list");
      const backFooterNoteEl = document.getElementById("back-footer-note");

      const titleEl = document.getElementById("main-title");
      const subtitleEl = document.getElementById("subtitle");
      const directionsEl = document.getElementById("directions");
      const backToSportsBtn = document.getElementById("back-to-sports");

      const sportsMenuEl = document.getElementById("sports-menu");
      const appLogoButton = document.getElementById("app-logo-button");
      const logoGroup = document.getElementById("logo-group");

      const userMenuButton = document.getElementById("user-menu-button");
      const userMenuLabel = document.getElementById("user-menu-label");
      const userDropdown = document.getElementById("user-dropdown");
      const userMenuWrapper = document.getElementById("user-menu-wrapper");

      const swipeToastEl = document.getElementById("swipe-toast");

      // Modal
      const modalOverlay = document.getElementById("modal-overlay");
      const modalTitle = document.getElementById("modal-title");
      const modalBody = document.getElementById("modal-body");
      const modalActions = document.getElementById("modal-actions");

      // Auth
      const authOverlay = document.getElementById("auth-overlay");
      const authEmail = document.getElementById("email");
      const authPass = document.getElementById("password");
      const signInBtn = document.getElementById("signInBtn");
      const signUpBtn = document.getElementById("signUpBtn");
      const authNote = document.getElementById("auth-note");

      /************************************************************
       * SUPABASE
       ************************************************************/
      window.supabase = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
        auth: { persistSession: true, autoRefreshToken: true }
      });

      /************************************************************
       * UTIL
       ************************************************************/
      function getNextIndex(length, current) { return (current + 1) % length; }
      function getPrevIndex(length, current) { return current === 0 ? length - 1 : current - 1; }
      function currentSport() { return SPORTS[currentSportIndex]; }
      function currentMatchup() { return currentSport().matchups[currentMatchupIndex]; }

      function toast(msg) {
        swipeToastEl.textContent = msg;
        swipeToastEl.classList.add("show");
        clearTimeout(swipeToastEl._t);
        swipeToastEl._t = setTimeout(() => swipeToastEl.classList.remove("show"), 1100);
      }

      function openModal({ title, body, buttons }) {
        modalTitle.textContent = title || "Confirm";
        modalBody.textContent = body || "";
        modalActions.innerHTML = "";

        (buttons || []).forEach((b) => {
          const btn = document.createElement("button");
          btn.className = "modal-btn" + (b.variant ? " " + b.variant : "");
          btn.textContent = b.label || "OK";
          btn.addEventListener("click", () => {
            closeModal();
            if (typeof b.onClick === "function") b.onClick();
          });
          modalActions.appendChild(btn);
        });

        modalOverlay.classList.add("open");
      }
      function closeModal() { modalOverlay.classList.remove("open"); }
      modalOverlay.addEventListener("click", (e) => {
        if (e.target === modalOverlay) closeModal();
      });

      function setTheme(next) {
        document.documentElement.setAttribute("data-theme", next);
        localStorage.setItem(LS_THEME, next);
      }
      function initTheme() {
        const saved = localStorage.getItem(LS_THEME);
        if (saved === "dark" || saved === "light") setTheme(saved);
        else setTheme("light");
      }

      /************************************************************
       * COMMUNITY REVEAL LOGIC
       * - before userSwipeCount >= 5:
       *   show 50/50 in blue for all lines
       * - after:
       *   show real community in green
       ************************************************************/
      function hasRevealedCommunity() {
        return userSwipeCount >= REVEAL_COMMUNITY_AFTER;
      }

      function getDisplayedBias(meta, communityConfident, communityDoubt) {
        if (!hasRevealedCommunity()) {
          return { confident: 50, doubt: 50, revealed: false };
        }
        const c = typeof communityConfident === "number" ? communityConfident : 55;
        const d = typeof communityDoubt === "number" ? communityDoubt : (100 - c);
        return { confident: c, doubt: d, revealed: true };
      }

      /************************************************************
       * STORAGE HELPERS
       ************************************************************/
      function makeKey(sportId, matchupName, label, book) {
        return `${sportId}|${matchupName}|${label}|${book || "Best"}`;
      }

      function getMyBiasItems() {
        return Object.values(store).filter((x) => x.status === "mybias");
      }
      function getLockItems() {
        return Object.values(store).filter((x) => x.status === "lock");
      }
      function getArchivedItems() {
        return Object.values(store).filter((x) => x.status === "archived");
      }

      function sortHot(items) {
        // "hot" heuristic: updatedAt desc
        return items.sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0));
      }

      function moveToBottom(cardEl) {
        if (!cardEl || !cardEl.parentNode) return;
        cardEl.parentNode.appendChild(cardEl);
      }

      /************************************************************
       * PERSISTENCE (SUPABASE + fallback)
       ************************************************************/
      async function persistUpsert(item) {
        // Always mirror to localStorage as safety
        persistToLocalStorage();

        // Supabase cross-device
        if (!window.supabase || !isAuthed || !currentUser?.id) return;

        try {
          const payload = {
            user_id: currentUser.id,
            key: item.key,
            sport_id: item.sportId,
            matchup_name: item.matchupName,
            line_label: item.label,
            book: item.book,
            category: item.category,
            vote: item.vote,
            status: item.status,
            sport_index: item.sportIndex,
            matchup_index: item.matchupIndex,
            created_at: new Date(item.createdAt).toISOString(),
            updated_at: new Date(item.updatedAt).toISOString()
          };

          const { error } = await window.supabase
            .from(PERSIST_TABLE)
            .upsert(payload, { onConflict: "user_id,key" });

          if (error) {
            console.warn("Supabase upsert failed (table/policy?)", error);
          }
        } catch (e) {
          console.warn("Supabase upsert exception", e);
        }
      }

      async function persistDelete(item) {
        persistToLocalStorage();
        if (!window.supabase || !isAuthed || !currentUser?.id) return;

        try {
          const { error } = await window.supabase
            .from(PERSIST_TABLE)
            .delete()
            .eq("user_id", currentUser.id)
            .eq("key", item.key);

          if (error) console.warn("Supabase delete failed", error);
        } catch (e) {
          console.warn("Supabase delete exception", e);
        }
      }

      function persistToLocalStorage() {
        try {
          localStorage.setItem(
            LS_KEY,
            JSON.stringify({
              user_id: currentUser?.id || null,
              userSwipeCount,
              items: store
            })
          );
        } catch {}
      }

      function loadFromLocalStorage() {
        try {
          const raw = localStorage.getItem(LS_KEY);
          if (!raw) return;
          const parsed = JSON.parse(raw);
          if (parsed && typeof parsed === "object") {
            if (typeof parsed.userSwipeCount === "number") userSwipeCount = parsed.userSwipeCount;
            if (parsed.items && typeof parsed.items === "object") {
              Object.keys(parsed.items).forEach((k) => (store[k] = parsed.items[k]));
            }
          }
        } catch {}
      }

      async function loadFromSupabase() {
        if (!window.supabase || !isAuthed || !currentUser?.id) return;

        try {
          const { data, error } = await window.supabase
            .from(PERSIST_TABLE)
            .select("*")
            .eq("user_id", currentUser.id);

          if (error) {
            console.warn("Supabase load failed (table/policy?)", error);
            return;
          }
          if (!Array.isArray(data)) return;

          data.forEach((row) => {
            const key = row.key;
            store[key] = {
              key,
              user_id: row.user_id,
              sportId: row.sport_id,
              matchupName: row.matchup_name,
              label: row.line_label,
              book: row.book,
              category: row.category,
              vote: row.vote,
              status: row.status,
              sportIndex: row.sport_index ?? 0,
              matchupIndex: row.matchup_index ?? 0,
              createdAt: row.created_at ? new Date(row.created_at).getTime() : Date.now(),
              updatedAt: row.updated_at ? new Date(row.updated_at).getTime() : Date.now()
            };
          });
        } catch (e) {
          console.warn("Supabase load exception", e);
        }
      }

      /************************************************************
       * SWIPE + HOLD BEHAVIOR (ONE LINE ONLY)
       ************************************************************/
      function attachSwipeAndHold(card, meta, context) {
        let startX = null;
        let isPointerDown = false;

        let holdTimer = null;
        let held = false;

        const getItemKey = () => makeKey(meta.sportId, meta.matchupName, meta.label, meta.book);

        function canInteract() {
          if (!isAuthed) return false;
          const key = getItemKey();
          const existing = store[key];
          return !(existing && existing._disabled);
        }

        card.addEventListener("pointerdown", (e) => {
          if (!canInteract()) return;

          isPointerDown = true;
          startX = e.clientX;
          held = false;

          // Press+hold: offer change bias / remove from locks
          holdTimer = setTimeout(() => {
            held = true;
            e.stopPropagation();
            const key = getItemKey();
            const item = store[key];

            if (!item) return;

            if (item.status === "lock") {
              openModal({
                title: "Remove from MyLocks?",
                body: "This line will be removed from MyLocks and put back into MyBias.",
                buttons: [
                  { label: "Cancel" },
                  {
                    label: "Remove",
                    variant: "danger",
                    onClick: async () => {
                      item.status = "mybias";
                      item.updatedAt = Date.now();
                      item._disabled = false; // re-enable in MyBias
                      await persistUpsert(item);
                      toast("Removed from MyLocks");
                      renderScreen();
                    }
                  }
                ]
              });
              return;
            }

            openModal({
              title: "Change your bias?",
              body: "This flips ONLY this one line (Confident ‚Üî Doubt It).",
              buttons: [
                { label: "Cancel" },
                {
                  label: "Yes, flip it",
                  variant: "primary",
                  onClick: async () => {
                    item.vote = item.vote === "confident" ? "doubt" : "confident";
                    item.updatedAt = Date.now();

                    // If it lives in MyBias, keep it there; if it's in locks/archives, keep status
                    await persistUpsert(item);

                    toast(item.vote === "confident" ? "Confident ‚úÖ" : "Doubt It ü§î");
                    renderScreen();
                  }
                }
              ]
            });
          }, 700);
        });

        card.addEventListener("pointerup", async (e) => {
          if (!isPointerDown) return;
          isPointerDown = false;
          clearTimeout(holdTimer);
          holdTimer = null;

          // If user held, do not treat as swipe
          if (held) return;

          if (!canInteract()) return;

          const dx = e.clientX - startX;
          const threshold = 40;
          if (Math.abs(dx) < threshold) return;

          e.stopPropagation();

          const direction = dx > 0 ? "right" : "left";
          const vote = direction === "right" ? "confident" : "doubt";

          // Save/update item
          const key = getItemKey();
          const now = Date.now();

          // Get community bias values, but display may be hidden until 5 swipes
          const { confident: shownConf, doubt: shownDoubt } = getDisplayedBias(
            meta,
            meta.communityConfident,
            meta.communityDoubt
          );

          let item = store[key];
          if (!item) {
            item = {
              key,
              user_id: currentUser?.id || null,
              sportId: meta.sportId,
              sportIndex: meta.sportIndex,
              matchupIndex: meta.matchupIndex,
              matchupName: meta.matchupName,
              label: meta.label,
              category: meta.category || "other",
              book: meta.book || "Best Available",
              vote,
              status: "mybias",
              createdAt: now,
              updatedAt: now
            };
            store[key] = item;
          } else {
            item.vote = vote;
            item.updatedAt = now;
          }

          // Count swipes (for reveal)
          userSwipeCount += 1;

          // If on MyBias screen, move OUT of MyBias immediately to Locks/Archives
          if (context === "mybias") {
            item.status = vote === "confident" ? "lock" : "archived";
          } else {
            // In other screens, first swipe puts it into MyBias
            item.status = "mybias";
          }

          // Disable in-place UI: grey + move to bottom + cannot swipe again
          item._disabled = true;
          card.classList.add("disabled");
          moveToBottom(card);

          // Update displayed bar on the swiped card (if present)
          const fill = card.querySelector(".bias-bar-fill");
          const leftLabel = card.querySelector("[data-bias-left]");
          const rightLabel = card.querySelector("[data-bias-right]");
          if (fill && leftLabel && rightLabel) {
            const reveal = hasRevealedCommunity();
            const conf = reveal ? (meta.communityConfident ?? 55) : 50;
            const doubt = reveal ? (meta.communityDoubt ?? (100 - conf)) : 50;

            fill.style.width = conf + "%";
            fill.style.background = reveal
              ? `linear-gradient(90deg, var(--green), rgba(22,163,74,0.65))`
              : `linear-gradient(90deg, var(--blue), rgba(37,99,235,0.65))`;

            // LEFT must be Doubt It, RIGHT must be Confident
            leftLabel.textContent = `Doubt It ${doubt}%`;
            rightLabel.textContent = `Confident ${conf}%`;
          }

          // Persist BEFORE UI navigation
          await persistUpsert(item);

          // Toast
          toast(vote === "confident" ? "Confident ‚úÖ" : "Doubt It ü§î");

          // If reveal just triggered, refresh UI so bars flip from blue to green everywhere
          if (userSwipeCount === REVEAL_COMMUNITY_AFTER) {
            toast("Community SideBias unlocked üîì");
            renderScreen();
          }
        });

        card.addEventListener("pointercancel", () => {
          isPointerDown = false;
          clearTimeout(holdTimer);
          holdTimer = null;
        });

        // Double-click line opens details
        card.addEventListener("dblclick", (e) => {
          e.stopPropagation();
          openLineDetails(meta);
        });
      }

      /************************************************************
       * BUILD SIDEBIAS UI (Doubt It LEFT, Confident RIGHT)
       ************************************************************/
      function buildSideBiasUI(meta) {
        const container = document.createElement("div");
        container.className = "bias-container";

        const barBg = document.createElement("div");
        barBg.className = "bias-bar-bg";

        const barFill = document.createElement("div");
        barFill.className = "bias-bar-fill";

        const displayed = getDisplayedBias(meta, meta.communityConfident, meta.communityDoubt);
        barFill.style.width = displayed.confident + "%";
        barFill.style.background = displayed.revealed
          ? `linear-gradient(90deg, var(--green), rgba(22,163,74,0.65))`
          : `linear-gradient(90deg, var(--blue), rgba(37,99,235,0.65))`;

        barBg.appendChild(barFill);

        const labels = document.createElement("div");
        labels.className = "bias-labels";

        // LEFT = Doubt It
        const left = document.createElement("div");
        left.className = "bias-left";
        left.setAttribute("data-bias-left", "1");
        left.textContent = `Doubt It ${displayed.doubt}%`;

        // RIGHT = Confident
        const right = document.createElement("div");
        right.className = "bias-right";
        right.setAttribute("data-bias-right", "1");
        right.textContent = `Confident ${displayed.confident}%`;

        labels.appendChild(left);
        labels.appendChild(right);

        container.appendChild(barBg);
        container.appendChild(labels);

        return container;
      }

      /************************************************************
       * LINE DETAILS (Placeholder; same size as everything else)
       ************************************************************/
      function openLineDetails(meta) {
        previousModeBeforeLineDetails = mode === "lineDetails" ? previousModeBeforeLineDetails : mode;
        currentLineDetailMeta = meta;
        mode = "lineDetails";
        flipped = true;
        renderScreen();
      }

      function renderLineDetailsFront() {
        logoEl.textContent = "üìà";
        nameEl.textContent = "Line Details";
        codeEl.textContent = "Placeholder stats for now";
        tapHintFrontEl.textContent = "Double-click center to flip ‚Üª";
        indexIndicatorFront.textContent = "";
        indexIndicatorBack.textContent = "";
      }

      function renderLineDetailsBack() {
        const meta = currentLineDetailMeta;
        backTitleEl.textContent = "Line Details";
        backSubEl.textContent = meta ? `${meta.matchupName} ‚Ä¢ ${meta.label}` : "Unknown line";
        backFooterNoteEl.style.display = "none";
        matchupsListEl.innerHTML = "";

        const card = document.createElement("div");
        card.className = "matchup-card";

        const t = document.createElement("div");
        t.className = "matchup-label";
        t.textContent = meta?.label || "Line";

        const p1 = document.createElement("div");
        p1.className = "matchup-line";
        p1.textContent = "Placeholder: season average, last 10, home/away, vs opponent.";

        const p2 = document.createElement("div");
        p2.className = "matchup-line";
        p2.textContent = "Placeholder: injury note, pace/tempo, matchup edge, weather (NFL).";

        const p3 = document.createElement("div");
        p3.className = "matchup-line";
        p3.textContent = "Placeholder: hit rate this season: 64% ‚Ä¢ last 5: W W L W W";

        card.appendChild(t);
        card.appendChild(p1);
        card.appendChild(p2);
        card.appendChild(p3);

        matchupsListEl.appendChild(card);
      }

      /************************************************************
       * RENDER HELPERS
       ************************************************************/
      function renderCardFlipState() {
        if (flipped) cardEl.classList.add("flipped");
        else cardEl.classList.remove("flipped");
      }

      function renderSportsFront() {
        const sport = currentSport();
        logoEl.textContent = sport.emoji;
        nameEl.textContent = sport.name;
        codeEl.textContent = sport.code;
        tapHintFrontEl.textContent = "Double-click center to flip ‚Üª";
        const idx = `${currentSportIndex + 1} / ${SPORTS.length}`;
        indexIndicatorFront.textContent = idx;
        indexIndicatorBack.textContent = idx;
      }

      function makeLineCard({ title, sub1, sub2, tag, meta, context }) {
        const card = document.createElement("div");
        card.className = "matchup-card";

        const top = document.createElement("div");
        top.className = "matchup-top";

        const left = document.createElement("div");
        const label = document.createElement("div");
        label.className = "matchup-label";
        label.textContent = title;

        const line1 = document.createElement("div");
        line1.className = "matchup-line";
        line1.textContent = sub1 || "";

        const line2 = document.createElement("div");
        line2.className = "matchup-line";
        line2.textContent = sub2 || "";

        left.appendChild(label);
        if (sub1) left.appendChild(line1);
        if (sub2) left.appendChild(line2);

        const right = document.createElement("div");
        right.className = "matchup-tag";
        right.textContent = tag || "";

        top.appendChild(left);
        top.appendChild(right);

        card.appendChild(top);

        // SideBias bar
        card.appendChild(buildSideBiasUI(meta));

        // Disable if already swiped
        const key = makeKey(meta.sportId, meta.matchupName, meta.label, meta.book);
        if (store[key] && store[key]._disabled) {
          card.classList.add("disabled");
        }

        // Attach swipe + hold + dblclick
        attachSwipeAndHold(card, meta, context);

        return card;
      }

      function renderSportsBack() {
        const sport = currentSport();
        backTitleEl.textContent = `${sport.name} ‚Äì This Week's Games`;
        backSubEl.textContent = "Double-click a game to open All Lines.";
        backFooterNoteEl.style.display = "block";

        matchupsListEl.innerHTML = "";

        sport.matchups.forEach((matchup, mIndex) => {
          const topLine = matchup.lines[0] || { label: "No lines yet", category: "other", book: "Consensus", communityConfident: 50, communityDoubt: 50 };

          const meta = {
            sportId: sport.id,
            sportIndex: currentSportIndex,
            matchupIndex: mIndex,
            matchupName: matchup.name,
            label: topLine.label,
            category: topLine.category || "other",
            book: topLine.book || "Consensus",
            communityConfident: topLine.communityConfident,
            communityDoubt: topLine.communityDoubt
          };

          const card = makeLineCard({
            title: matchup.name,
            sub1: topLine.label,
            sub2: "Swipe: LEFT = Doubt It ‚Ä¢ RIGHT = Confident ‚Ä¢ Hold to change",
            tag: topLine.book || "Consensus",
            meta,
            context: "sportsPreview"
          });

          // dblclick game opens All Lines
          card.addEventListener("dblclick", (e) => {
            e.stopPropagation();
            mode = "allLines";
            currentMatchupIndex = mIndex;
            flipped = true;
            renderScreen();
          });

          matchupsListEl.appendChild(card);
        });
      }

      function renderMatchupsFront() {
        const sport = currentSport();
        const matchup = currentMatchup();

        logoEl.textContent = sport.emoji;
        nameEl.textContent = matchup.name;
        codeEl.textContent = sport.name;
        tapHintFrontEl.textContent = "Double-click center to flip ‚Üª";

        const idx = `${currentMatchupIndex + 1} / ${sport.matchups.length}`;
        indexIndicatorFront.textContent = idx;
        indexIndicatorBack.textContent = idx;
      }

      function renderMatchupsBack() {
        const sport = currentSport();
        const matchup = currentMatchup();

        backTitleEl.textContent = `${sport.name} ‚Äì Top Lines`;
        backSubEl.textContent = "Swipe lines to add to MyBias. Double-click for details. Hold to change.";
        backFooterNoteEl.style.display = "block";

        matchupsListEl.innerHTML = "";

        const linesToShow = matchup.lines.slice(0, 6);

        linesToShow.forEach((ln) => {
          const meta = {
            sportId: sport.id,
            sportIndex: currentSportIndex,
            matchupIndex: currentMatchupIndex,
            matchupName: matchup.name,
            label: ln.label,
            category: ln.category || "other",
            book: ln.book || "Consensus",
            communityConfident: ln.communityConfident,
            communityDoubt: ln.communityDoubt
          };

          const card = makeLineCard({
            title: ln.label,
            sub1: matchup.name,
            sub2: "Swipe: LEFT = Doubt It ‚Ä¢ RIGHT = Confident",
            tag: ln.book || "Consensus",
            meta,
            context: "matchupsTop"
          });

          matchupsListEl.appendChild(card);
        });
      }

      function renderAllLinesBack() {
        const sport = currentSport();
        const matchup = currentMatchup();

        backTitleEl.textContent = `${sport.name} ‚Äì All Lines`;
        backSubEl.textContent = "Swipe lines to add to MyBias. Double-click for details.";
        backFooterNoteEl.style.display = "block";

        matchupsListEl.innerHTML = "";

        // extend demo list a bit with alternates
        const baseLines = matchup.lines || [];
        let extendedLines = baseLines.slice();

        let altCounter = 1;
        while (extendedLines.length < 14 && baseLines.length > 0) {
          const template = baseLines[(extendedLines.length - baseLines.length) % baseLines.length];
          const cat =
            template.category === "spread" || template.category === "total" || template.category === "points"
              ? "alt"
              : template.category || "alt";

          extendedLines.push({
            ...template,
            label: `${template.label} (Alt ${altCounter})`,
            category: cat
          });
          altCounter++;
        }

        const grouped = {};
        extendedLines.forEach((ln) => {
          const cat = ln.category || "other";
          if (!grouped[cat]) grouped[cat] = [];
          grouped[cat].push(ln);
        });

        CATEGORY_ORDER.forEach((catKey) => {
          const linesInCat = grouped[catKey];
          if (!linesInCat || linesInCat.length === 0) return;

          const header = document.createElement("div");
          header.className = "category-header";
          header.textContent = CATEGORY_LABELS[catKey] || CATEGORY_LABELS.other;
          matchupsListEl.appendChild(header);

          linesInCat.forEach((ln) => {
            const meta = {
              sportId: sport.id,
              sportIndex: currentSportIndex,
              matchupIndex: currentMatchupIndex,
              matchupName: matchup.name,
              label: ln.label,
              category: ln.category || "other",
              book: ln.book || "Consensus",
              communityConfident: ln.communityConfident,
              communityDoubt: ln.communityDoubt
            };

            const card = makeLineCard({
              title: ln.label,
              sub1: matchup.name,
              sub2: "Swipe: LEFT = Doubt It ‚Ä¢ RIGHT = Confident",
              tag: ln.book || "Consensus",
              meta,
              context: "allLines"
            });

            matchupsListEl.appendChild(card);
          });
        });
      }

      function renderMyBiasFront() {
        logoEl.textContent = "üß†";
        nameEl.textContent = "MyBias";
        codeEl.textContent = "Your swipes (swipe again here to Lock or Archive)";
        tapHintFrontEl.textContent = "Double-click center to flip ‚Üª";
        indexIndicatorFront.textContent = "";
        indexIndicatorBack.textContent = "";
      }

      function renderMyBiasBack() {
        backTitleEl.textContent = "MyBias";
        backSubEl.textContent =
          "Swipe RIGHT to lock (MyLocks). Swipe LEFT to archive (MyArchives). Hold any line to flip your bias.";
        backFooterNoteEl.style.display = "none";

        matchupsListEl.innerHTML = "";

        const items = sortHot(getMyBiasItems());

        if (items.length === 0) {
          const empty = document.createElement("div");
          empty.className = "matchup-card";
          const t = document.createElement("div");
          t.className = "matchup-label";
          t.textContent = "Nothing in MyBias yet";
          const p = document.createElement("div");
          p.className = "matchup-line";
          p.textContent = "Go swipe lines in sports to add them here.";
          empty.appendChild(t);
          empty.appendChild(p);
          matchupsListEl.appendChild(empty);
          return;
        }

        items.forEach((it) => {
          const meta = {
            sportId: it.sportId,
            sportIndex: it.sportIndex,
            matchupIndex: it.matchupIndex,
            matchupName: it.matchupName,
            label: it.label,
            category: it.category || "other",
            book: it.book || "Best Available",
            // show actual community only after reveal
            communityConfident: 55,
            communityDoubt: 45
          };

          const card = makeLineCard({
            title: it.label,
            sub1: `${it.matchupName} ‚Ä¢ ${it.sportId.toUpperCase()} ‚Ä¢ ${it.book}`,
            sub2: `Your pick: ${it.vote === "confident" ? "Confident ‚úÖ" : "Doubt It ü§î"} ‚Ä¢ Swipe again: RIGHT=Lock / LEFT=Archive`,
            tag: it.status,
            meta,
            context: "mybias"
          });

          // In MyBias we want it swipable again, even if earlier disabled in other screens
          // But once swiped here, it will disable in-place and then disappear on next render (moves to locks/archives)
          card.classList.remove("disabled");

          // override disabled check
          const key = it.key;
          if (store[key]) store[key]._disabled = false;

          matchupsListEl.appendChild(card);
        });
      }

      function renderLocksFront() {
        logoEl.textContent = "üîí";
        nameEl.textContent = "MyLocks";
        codeEl.textContent = "Saved locks (persistent across devices)";
        tapHintFrontEl.textContent = "Double-click center to flip ‚Üª";
        indexIndicatorFront.textContent = "";
        indexIndicatorBack.textContent = "";
      }

      function renderLocksBack() {
        backTitleEl.textContent = "MyLocks";
        backSubEl.textContent = "Hold a lock to remove it back to MyBias. Double-click for details.";
        backFooterNoteEl.style.display = "none";

        matchupsListEl.innerHTML = "";

        const locks = sortHot(getLockItems());

        if (locks.length === 0) {
          const empty = document.createElement("div");
          empty.className = "matchup-card";
          const t = document.createElement("div");
          t.className = "matchup-label";
          t.textContent = "No locks yet";
          const p = document.createElement("div");
          p.className = "matchup-line";
          p.textContent = "From MyBias, swipe RIGHT to lock.";
          empty.appendChild(t);
          empty.appendChild(p);
          matchupsListEl.appendChild(empty);
          return;
        }

        locks.forEach((it) => {
          const meta = {
            sportId: it.sportId,
            sportIndex: it.sportIndex,
            matchupIndex: it.matchupIndex,
            matchupName: it.matchupName,
            label: it.label,
            category: it.category || "other",
            book: it.book || "Best Available",
            communityConfident: 55,
            communityDoubt: 45
          };

          const card = makeLineCard({
            title: it.label,
            sub1: `${it.matchupName} ‚Ä¢ ${it.sportId.toUpperCase()} ‚Ä¢ ${it.book}`,
            sub2: `Your lock: ${it.vote === "confident" ? "Confident ‚úÖ" : "Doubt It ü§î"} ‚Ä¢ Hold to remove`,
            tag: "LOCKED",
            meta,
            context: "locks"
          });

          // locks should not be swipable (only hold to remove), so disable swipe by marking disabled and ignoring swipes
          card.classList.add("disabled");
          // keep hold behavior via attachSwipeAndHold; swipe won't do anything because _disabled is true
          const key = it.key;
          if (store[key]) store[key]._disabled = true;

          matchupsListEl.appendChild(card);
        });
      }

      function renderArchivesFront() {
        logoEl.textContent = "üóÉÔ∏è";
        nameEl.textContent = "MyArchives";
        codeEl.textContent = "Archived lines (persistent across devices)";
        tapHintFrontEl.textContent = "Double-click center to flip ‚Üª";
        indexIndicatorFront.textContent = "";
        indexIndicatorBack.textContent = "";
      }

      function renderArchivesBack() {
        backTitleEl.textContent = "MyArchives";
        backSubEl.textContent = "Hold a line to flip your bias. Double-click for details.";
        backFooterNoteEl.style.display = "none";

        matchupsListEl.innerHTML = "";

        const items = sortHot(getArchivedItems());

        if (items.length === 0) {
          const empty = document.createElement("div");
          empty.className = "matchup-card";
          const t = document.createElement("div");
          t.className = "matchup-label";
          t.textContent = "Nothing archived";
          const p = document.createElement("div");
          p.className = "matchup-line";
          p.textContent = "From MyBias, swipe LEFT to archive.";
          empty.appendChild(t);
          empty.appendChild(p);
          matchupsListEl.appendChild(empty);
          return;
        }

        items.forEach((it) => {
          const meta = {
            sportId: it.sportId,
            sportIndex: it.sportIndex,
            matchupIndex: it.matchupIndex,
            matchupName: it.matchupName,
            label: it.label,
            category: it.category || "other",
            book: it.book || "Best Available",
            communityConfident: 55,
            communityDoubt: 45
          };

          const card = makeLineCard({
            title: it.label,
            sub1: `${it.matchupName} ‚Ä¢ ${it.sportId.toUpperCase()} ‚Ä¢ ${it.book}`,
            sub2: `Archived: ${it.vote === "confident" ? "Confident ‚úÖ" : "Doubt It ü§î"} ‚Ä¢ Hold to flip`,
            tag: "ARCHIVED",
            meta,
            context: "archives"
          });

          // archives should not be swipable again
          card.classList.add("disabled");
          const key = it.key;
          if (store[key]) store[key]._disabled = true;

          matchupsListEl.appendChild(card);
        });
      }

      /************************************************************
       * SCREEN ROUTER
       ************************************************************/
      function renderScreen() {
        if (!isAuthed) {
          // enforce no swiping unless logged in
          appShell.style.display = "none";
          authOverlay.style.display = "flex";
          return;
        }

        appShell.style.display = "flex";
        authOverlay.style.display = "none";

        if (mode === "sports") {
          titleEl.textContent = "Select Your Sport";
          subtitleEl.textContent = "One card at a time. Most popular games by sport.";
          directionsEl.innerHTML =
            'Double-click the <strong>center</strong> to flip. Tap <strong>right edge</strong> for next sport, <strong>left edge</strong> for previous.';
          backToSportsBtn.style.display = "none";

          renderSportsFront();
          renderSportsBack();
        } else if (mode === "matchups") {
          const sport = currentSport();
          titleEl.textContent = `${sport.name} Games`;
          subtitleEl.textContent = "Each card is a matchup.";
          directionsEl.innerHTML =
            'Double-click the <strong>center</strong> to flip. Swipe lines: <strong>LEFT = Doubt It</strong>, <strong>RIGHT = Confident</strong>. Double-click a line for details.';
          backToSportsBtn.style.display = "inline-flex";

          renderMatchupsFront();
          renderMatchupsBack();
        } else if (mode === "allLines") {
          const sport = currentSport();
          const matchup = currentMatchup();
          titleEl.textContent = `${sport.name} ‚Äì All Lines`;
          subtitleEl.textContent = matchup.name;

          directionsEl.innerHTML =
            'In All Lines: <strong>single click changes game</strong> (no flip). <strong>Double-click center</strong> flips. Swipe lines: LEFT=Doubt It, RIGHT=Confident.';
          backToSportsBtn.style.display = "inline-flex";

          renderMatchupsFront();
          renderAllLinesBack();
        } else if (mode === "lineDetails") {
          titleEl.textContent = "Line Details";
          subtitleEl.textContent = currentLineDetailMeta?.matchupName || "";
          directionsEl.innerHTML =
            'Placeholder stats. Double-click center to flip back. Use the <strong>Back</strong> button to return.';
          backToSportsBtn.style.display = "inline-flex";

          renderLineDetailsFront();
          renderLineDetailsBack();
        } else if (mode === "mybias") {
          titleEl.textContent = "MyBias";
          subtitleEl.textContent = "Your swipes ‚Äî lock or archive them from here.";
          directionsEl.innerHTML =
            'In MyBias: swipe <strong>RIGHT</strong> to Lock, swipe <strong>LEFT</strong> to Archive. Hold to flip your bias.';
          backToSportsBtn.style.display = "inline-flex";

          renderMyBiasFront();
          renderMyBiasBack();
          flipped = true;
        } else if (mode === "locks") {
          titleEl.textContent = "MyLocks";
          subtitleEl.textContent = "Persistent across devices.";
          directionsEl.innerHTML =
            'Hold a lock to remove it back to MyBias. Double-click a line for details.';
          backToSportsBtn.style.display = "inline-flex";

          renderLocksFront();
          renderLocksBack();
          flipped = true;
        } else if (mode === "archives") {
          titleEl.textContent = "MyArchives";
          subtitleEl.textContent = "Persistent across devices.";
          directionsEl.innerHTML =
            'Hold a line to flip your bias (only that line). Double-click for details.';
          backToSportsBtn.style.display = "inline-flex";

          renderArchivesFront();
          renderArchivesBack();
          flipped = true;
        }

        renderCardFlipState();
        updateUserDropdownBadges();
      }

      function handleGlobalBack() {
        if (mode === "lineDetails" && previousModeBeforeLineDetails) {
          mode = previousModeBeforeLineDetails;
          flipped = true;
        } else if (mode === "allLines") {
          mode = "matchups";
          flipped = true;
        } else if (mode === "matchups") {
          mode = "sports";
          flipped = false;
        } else if (mode === "mybias" || mode === "locks" || mode === "archives") {
          mode = "sports";
          flipped = false;
        } else {
          return;
        }
        renderScreen();
      }

      backToSportsBtn.addEventListener("click", () => handleGlobalBack());

      /************************************************************
       * CARD CLICK BEHAVIOR
       * - Double-click center: flip
       * - In AllLines: single click changes game (matchup), does NOT flip
       * - In other modes: single click edges navigate; center does nothing (no flip)
       ************************************************************/
      const DOUBLE_CLICK_DELAY = 250;
      let clickTimeout = null;

      function handleSingleClick(e) {
        const rect = cardClickArea.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const zone = x / rect.width;

        if (mode === "allLines") {
          // Single click changes game; do not flip.
          if (zone < 0.5) {
            currentMatchupIndex = getPrevIndex(currentSport().matchups.length, currentMatchupIndex);
          } else {
            currentMatchupIndex = getNextIndex(currentSport().matchups.length, currentMatchupIndex);
          }
          // keep flipped state as-is (you asked: don't auto flip)
          renderScreen();
          return;
        }

        // no single-click flip anywhere (you asked flip should not happen after swipes)
        // but allow edge navigation in sports/matchups
        if (zone < 0.2) {
          if (mode === "sports") {
            currentSportIndex = getPrevIndex(SPORTS.length, currentSportIndex);
          } else if (mode === "matchups") {
            currentMatchupIndex = getPrevIndex(currentSport().matchups.length, currentMatchupIndex);
          }
          renderScreen();
        } else if (zone > 0.8) {
          if (mode === "sports") {
            currentSportIndex = getNextIndex(SPORTS.length, currentSportIndex);
          } else if (mode === "matchups") {
            currentMatchupIndex = getNextIndex(currentSport().matchups.length, currentMatchupIndex);
          }
          renderScreen();
        } else {
          // center single click: do nothing
        }
      }

      function handleDoubleClick(e) {
        const rect = cardClickArea.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const zone = x / rect.width;

        if (mode === "sports" && zone >= 0.2 && zone <= 0.8) {
          mode = "matchups";
          currentMatchupIndex = 0;
          // do not auto flip; user double-clicked, so we flip now
          flipped = true;
          renderScreen();
          return;
        }

        if (mode === "matchups" && zone >= 0.2 && zone <= 0.8) {
          mode = "allLines";
          flipped = true;
          renderScreen();
          return;
        }

        // Default: flip (front/back)
        flipped = !flipped;
        renderCardFlipState();
      }

      cardClickArea.addEventListener("click", (e) => {
        if (clickTimeout) {
          clearTimeout(clickTimeout);
          clickTimeout = null;
          handleDoubleClick(e);
        } else {
          clickTimeout = setTimeout(() => {
            handleSingleClick(e);
            clickTimeout = null;
          }, DOUBLE_CLICK_DELAY);
        }
      });

      /************************************************************
       * MENUS
       ************************************************************/
      function buildSportsMenu() {
        sportsMenuEl.innerHTML = "";
        SPORTS.forEach((sport, sIndex) => {
          const sportItem = document.createElement("div");
          sportItem.className = "sports-menu-item";

          const title = document.createElement("div");
          title.className = "sports-menu-item-title";
          title.textContent = sport.name;
          sportItem.appendChild(title);

          const gamesSub = document.createElement("div");
          gamesSub.className = "sports-games-submenu";

          sport.matchups.forEach((matchup, mIndex) => {
            const gameItem = document.createElement("div");
            gameItem.className = "game-item";
            gameItem.textContent = matchup.name;
            gameItem.addEventListener("click", (e) => {
              e.stopPropagation();
              currentSportIndex = sIndex;
              currentMatchupIndex = mIndex;
              mode = "allLines";
              flipped = false; // per your requirement: don't flip until double click
              sportsMenuEl.classList.remove("open");
              renderScreen();
            });
            gamesSub.appendChild(gameItem);
          });

          sportItem.appendChild(gamesSub);
          sportsMenuEl.appendChild(sportItem);
        });
      }

      appLogoButton.addEventListener("click", (e) => {
        e.stopPropagation();
        const isOpen = sportsMenuEl.classList.contains("open");
        sportsMenuEl.classList.toggle("open", !isOpen);
      });

      function updateUserDropdownBadges() {
        // optional: could add counts; kept minimal
      }

      function buildUserDropdown() {
        userDropdown.innerHTML = "";

        const makeItem = (label, onClick, rightText) => {
          const item = document.createElement("div");
          item.className = "user-dropdown-item";
          const left = document.createElement("span");
          left.textContent = label;
          const right = document.createElement("span");
          right.style.color = "var(--muted)";
          right.style.fontWeight = "800";
          right.textContent = rightText || "";
          item.appendChild(left);
          item.appendChild(right);
          item.addEventListener("click", onClick);
          return item;
        };

        userDropdown.appendChild(
          makeItem("MyBias", () => {
            mode = "mybias";
            flipped = true;
            userDropdown.classList.remove("open");
            renderScreen();
          }, String(getMyBiasItems().length))
        );

        userDropdown.appendChild(
          makeItem("MyLocks", () => {
            mode = "locks";
            flipped = true;
            userDropdown.classList.remove("open");
            renderScreen();
          }, String(getLockItems().length))
        );

        userDropdown.appendChild(
          makeItem("MyArchives", () => {
            mode = "archives";
            flipped = true;
            userDropdown.classList.remove("open");
            renderScreen();
          }, String(getArchivedItems().length))
        );

        const sep1 = document.createElement("div");
        sep1.className = "user-dropdown-separator";
        userDropdown.appendChild(sep1);

        // Theme toggle
        const currentTheme = document.documentElement.getAttribute("data-theme");
        userDropdown.appendChild(
          makeItem("Theme", () => {
            const next = currentTheme === "dark" ? "light" : "dark";
            setTheme(next);
            userDropdown.classList.remove("open");
            buildUserDropdown();
            toast(next === "dark" ? "Dark mode" : "Light mode");
          }, currentTheme === "dark" ? "Dark" : "Light")
        );

        const sep2 = document.createElement("div");
        sep2.className = "user-dropdown-separator";
        userDropdown.appendChild(sep2);

        userDropdown.appendChild(
          makeItem("Sign out", async () => {
            userDropdown.classList.remove("open");
            await signOut();
          })
        );
      }

      userMenuButton.addEventListener("click", (e) => {
        e.stopPropagation();
        const isOpen = userDropdown.classList.contains("open");
        userDropdown.classList.toggle("open", !isOpen);
      });

      function updateUserMenuLabel() {
        userMenuLabel.textContent = "My Hub";
      }

      /************************************************************
       * GLOBAL CLICK (close dropdowns, bottom-left back)
       ************************************************************/
      document.addEventListener("click", (e) => {
        const target = e.target;

        const clickedCard = cardClickArea.contains(target);
        const clickedBack = backToSportsBtn.contains(target);
        const clickedUserMenu = userMenuWrapper.contains(target);
        const clickedLogoMenu = logoGroup.contains(target);
        const clickedAuth = authOverlay.contains(target);
        const clickedModal = modalOverlay.contains(target);

        if (!clickedLogoMenu) sportsMenuEl.classList.remove("open");
        if (!clickedUserMenu) userDropdown.classList.remove("open");

        if (clickedCard || clickedBack || clickedUserMenu || clickedLogoMenu || clickedAuth || clickedModal) return;

        const vw = window.innerWidth;
        const vh = window.innerHeight;
        const x = e.clientX;
        const y = e.clientY;

        if (x < vw * 0.25 && y > vh * 0.75) handleGlobalBack();
      });

      /************************************************************
       * AUTH (required)
       ************************************************************/
      async function ensureAuth() {
        const { data } = await window.supabase.auth.getSession();
        if (data?.session?.user) {
          currentUser = data.session.user;
          isAuthed = true;
          return true;
        }
        isAuthed = false;
        currentUser = null;
        return false;
      }

      async function signIn() {
        const email = (authEmail.value || "").trim();
        const password = authPass.value || "";
        if (!email || !password) {
          toast("Enter email + password");
          return;
        }

        authNote.textContent = "Signing in‚Ä¶";

        const { data, error } = await window.supabase.auth.signInWithPassword({ email, password });

        if (error) {
          authNote.textContent = error.message;
          toast("Sign in failed");
          return;
        }

        // Confirm session exists
        const ok = await ensureAuth();
        if (!ok) {
          authNote.textContent = "Signed in, but session missing (check Supabase auth settings).";
          toast("Session missing");
          return;
        }

        // Load persistent items for this user (cross-device)
        await loadFromSupabase();

        authNote.textContent = "Signed in ‚úÖ";
        toast("Welcome back ‚úÖ");
        renderScreen();
      }

      async function signUp() {
        const email = (authEmail.value || "").trim();
        const password = authPass.value || "";
        if (!email || !password) {
          toast("Enter email + password");
          return;
        }

        authNote.textContent = "Creating account‚Ä¶";

        const { data, error } = await window.supabase.auth.signUp({
          email,
          password,
          options: {
            // If you have redirects configured in Supabase, this helps.
            emailRedirectTo: window.location.href
          }
        });

        if (error) {
          authNote.textContent = error.message;
          toast("Sign up failed");
          return;
        }

        // If email confirmation is required, Supabase returns user but may not return session.
        authNote.textContent =
          "Account created. If confirmation is enabled, check your email, confirm, then Sign In.";
        toast("Account created üì©");
      }

      async function signOut() {
        try {
          await window.supabase.auth.signOut();
        } catch {}
        isAuthed = false;
        currentUser = null;

        toast("Signed out");
        renderScreen();
      }

      signInBtn.addEventListener("click", (e) => {
        e.preventDefault();
        signIn();
      });

      signUpBtn.addEventListener("click", (e) => {
        e.preventDefault();
        signUp();
      });

      /************************************************************
       * (OPTIONAL) NFL LIVE ODDS + PROPS
       ************************************************************/
      async function fetchJsonSafe(url) {
        try {
          const r = await fetch(url);
          if (!r.ok) return null;
          return await r.json();
        } catch {
          return null;
        }
      }

      function applyLiveNflOdds(oddsData) {
        const nflSport = SPORTS.find((s) => s.id === "nfl");
        if (!nflSport) return;

        const mapped = [];

        oddsData.forEach((game) => {
          const homeName = game.HomeTeamName || game.HomeTeam || game.HomeTeamKey || "HOME";
          const awayName = game.AwayTeamName || game.AwayTeam || game.AwayTeamKey || "AWAY";
          const matchupName = `${awayName} @ ${homeName}`;

          const pre = game.PregameOdds || [];
          if (!pre.length) return;

          const lines = [];

          pre.forEach((odd) => {
            const book =
              odd.SportsbookName || odd.Sportsbook || odd.SportsBook || `Book ${odd.SportsbookId || ""}`.trim();

            // Spread
            if (typeof odd.Spread === "number" && odd.FavoredTeam) {
              lines.push({
                label: `${odd.FavoredTeam} ${odd.Spread > 0 ? "+" : ""}${odd.Spread}`,
                category: "spread",
                book,
                communityConfident: 55,
                communityDoubt: 45
              });
            }

            // Total
            if (typeof odd.OverUnder === "number") {
              lines.push({
                label: `Total ${odd.OverUnder}`,
                category: "total",
                book,
                communityConfident: 53,
                communityDoubt: 47
              });
            }

            // Moneyline home/away
            if (typeof odd.HomeTeamMoneyLine === "number") {
              const val = odd.HomeTeamMoneyLine;
              lines.push({
                label: `${homeName} ${val > 0 ? "+" : ""}${val} ML`,
                category: "moneyline",
                book,
                communityConfident: 52,
                communityDoubt: 48
              });
            }
            if (typeof odd.AwayTeamMoneyLine === "number") {
              const val = odd.AwayTeamMoneyLine;
              lines.push({
                label: `${awayName} ${val > 0 ? "+" : ""}${val} ML`,
                category: "moneyline",
                book,
                communityConfident: 52,
                communityDoubt: 48
              });
            }
          });

          if (!lines.length) return;

          mapped.push({
            name: matchupName,
            lines: lines.slice(0, 24),
            _scoreId: game.ScoreId || game.ScoreID || null
          });
        });

        if (mapped.length) {
          nflSport.matchups = mapped;
          buildSportsMenu();
        }
      }

      async function augmentNflMatchupsWithProps(oddsData) {
        const nflSport = SPORTS.find((s) => s.id === "nfl");
        if (!nflSport) return;

        const gamesWithScore = oddsData.filter((g) => g.ScoreId || g.ScoreID);
        const limited = gamesWithScore.slice(0, 4);

        for (const game of limited) {
          const scoreId = game.ScoreId || game.ScoreID;
          if (!scoreId) continue;

          const matchup = nflSport.matchups.find((m) => m._scoreId === scoreId || m._scoreId === Number(scoreId));
          if (!matchup) continue;

          const propsUrl = `https://api.sportsdata.io/v3/nfl/odds/json/BettingPlayerPropsByScoreID/${scoreId}?key=${NFL_API_KEY}`;
          const propsData = await fetchJsonSafe(propsUrl);
          if (!Array.isArray(propsData) || !propsData.length) continue;

          const propLines = [];
          propsData.forEach((prop) => {
            const book = prop.SportsbookName || prop.Sportsbook || prop.SportsBook || "Sportsbook";
            const playerName = prop.PlayerName || prop.Name || prop.ParticipantName || "Player";
            const statType =
              prop.BettingMarketTypeDescription || prop.BettingMarketType || prop.MarketDescription || "Prop";

            const baseValue =
              typeof prop.Value === "number" ? prop.Value : typeof prop.Total === "number" ? prop.Total : null;

            const overOutcome =
              (prop.BettingOutcomes || []).find(
                (o) => o.BettingOutcomeType === "Over" || o.BettingOutcomeType === "OVER" || o.OutcomeType === "Over"
              ) || null;

            const displayValue = overOutcome && typeof overOutcome.Value === "number" ? overOutcome.Value : baseValue;
            if (displayValue == null) return;

            propLines.push({
              label: `${playerName} o${displayValue} ${statType}`.replace(/\s+/g, " "),
              category: "props",
              book,
              communityConfident: 55,
              communityDoubt: 45
            });
          });

          if (propLines.length) {
            matchup.lines = matchup.lines.concat(propLines.slice(0, 10));
          }
        }
      }

      async function loadLiveNflOdds() {
        if (!NFL_API_KEY) return;

        const seasonUrl = `https://api.sportsdata.io/v3/nfl/scores/json/CurrentSeason?key=${NFL_API_KEY}`;
        const weekUrl = `https://api.sportsdata.io/v3/nfl/scores/json/CurrentWeek?key=${NFL_API_KEY}`;

        const seasonRaw = await fetchJsonSafe(seasonUrl);
        const weekRaw = await fetchJsonSafe(weekUrl);

        const season = Number(seasonRaw);
        const week = Number(weekRaw);
        if (!season || !week) return;

        const oddsUrl = `https://api.sportsdata.io/v3/nfl/odds/json/GameOddsByWeek/${season}/${week}?key=${NFL_API_KEY}`;
        const oddsData = await fetchJsonSafe(oddsUrl);
        if (!Array.isArray(oddsData) || !oddsData.length) return;

        applyLiveNflOdds(oddsData);
        await augmentNflMatchupsWithProps(oddsData);

        // refresh if user viewing NFL
        renderScreen();
      }

      /************************************************************
       * INIT
       ************************************************************/
      (async function init() {
        initTheme();
        updateUserMenuLabel();
        buildUserDropdown();
        buildSportsMenu();

        // Load local cache early
        loadFromLocalStorage();

        // Attempt session restore
        await ensureAuth();

        if (isAuthed) {
          // Merge cross-device data
          await loadFromSupabase();
          appShell.style.display = "flex";
          authOverlay.style.display = "none";
        } else {
          appShell.style.display = "none";
          authOverlay.style.display = "flex";
        }

        // Render initial view
        renderScreen();

        // Optional live NFL load
        document.addEventListener("DOMContentLoaded", () => {
          loadLiveNflOdds();
        });

        // Close menus on escape
        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape") {
            sportsMenuEl.classList.remove("open");
            userDropdown.classList.remove("open");
            closeModal();
          }
        });
      })();
    </script>
  </body>
</html>
